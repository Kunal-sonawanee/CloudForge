(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("PyodidePlugin", [], factory);
	else if(typeof exports === 'object')
		exports["PyodidePlugin"] = factory();
	else
		root["PyodidePlugin"] = factory();
})((typeof self !== 'undefined' ? self : this), () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/patterns.ts":
/*!*************************!*\
  !*** ./lib/patterns.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.chooseAndTransform = exports.transform = exports.choose = exports.versions = void 0;
const files = {
    "0.21.3": [
        "distutils.tar",
        "package.json",
        "pyodide_py.tar",
        "pyodide.asm.js",
        "pyodide.asm.js",
        "pyodide.asm.data",
        "pyodide.asm.wasm",
        "repodata.json",
    ],
    "0.22.1": [
        "package.json",
        "pyodide_py.tar",
        "pyodide.asm.js",
        "pyodide.asm.data",
        "pyodide.asm.wasm",
        "repodata.json",
    ],
    "0.23.0": ["package.json", "pyodide.asm.js", "pyodide.asm.wasm", "repodata.json", "python_stdlib.zip"],
    "0.24.0": function (pkg) {
        if (!pkg.files) {
            return [];
        }
        // list of files to ignore
        const ignore = [/^pyodide.m?js.*/, /.+\.d\.ts$/, /.+\.html$/];
        // files to ensure are always included
        const always = ["package.json"];
        const filtered = pkg.files.filter((file) => {
            return !ignore.some((v) => file.match(v));
        });
        always.forEach((f) => {
            if (!filtered.includes(f)) {
                filtered.push(f);
            }
        });
        return filtered;
    },
};
exports.versions = Object.keys(files);
/**
 * Choose the set of files to match for copying out of pyodide.
 * Based on the version passed. If no version is available in files to match
 * that is great enough an empty array is returned.
 * @param version
 * @returns {string[]}
 */
function choose(version = "0.0.0") {
    let chosen = [];
    for (let i = 0; i < exports.versions.length; i++) {
        if (version >= exports.versions[i]) {
            chosen = files[exports.versions[i]];
        }
    }
    return chosen;
}
exports.choose = choose;
/**
 * Choose the set of files to match for copying out of pyodide.
 * Based on the version passed. If no version is available in files to match
 * that is great enough an empty array is returned.
 * @param version
 * @param pattern
 * @param packageIndexUrl
 * @returns {PyodideObjectPattern[]}
 */
function transform(version, pattern, packageIndexUrl) {
    return pattern.map((name) => {
        let transform;
        if (packageIndexUrl && name == "pyodide.asm.js") {
            transform = {
                transformer: (input) => {
                    return input
                        .toString()
                        .replace("resolvePath(file_name,API.config.indexURL)", `resolvePath(file_name,"${packageIndexUrl}")`);
                },
            };
        }
        return { from: name, to: name, transform };
    });
}
exports.transform = transform;
function chooseAndTransform(pkg, packageIndexUrl) {
    packageIndexUrl = packageIndexUrl !== null && packageIndexUrl !== void 0 ? packageIndexUrl : `https://cdn.jsdelivr.net/pyodide/v${pkg.version}/full/`;
    let files = choose(pkg.version);
    if (typeof files === "function") {
        files = files(pkg);
    }
    return transform(pkg.version, files, packageIndexUrl);
}
exports.chooseAndTransform = chooseAndTransform;


/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PyodidePlugin = void 0;
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "assert"));
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const copy_webpack_plugin_1 = __importDefault(__webpack_require__(/*! copy-webpack-plugin */ "copy-webpack-plugin"));
const webpack_1 = __importDefault(__webpack_require__(/*! webpack */ "webpack"));
const patterns = __importStar(__webpack_require__(/*! ./lib/patterns */ "./lib/patterns.ts"));
const node_module_1 = __webpack_require__(/*! node:module */ "node:module");
function noop(_) {
    return _;
}
let dirname;
try {
    // @ts-ignore import.meta is only available in esm...
    dirname = __dirname;
}
catch (e) {
    noop(e);
}
class PyodidePlugin extends copy_webpack_plugin_1.default {
    constructor(options = {}) {
        let outDirectory = options.outDirectory || "pyodide";
        if (outDirectory.startsWith("/")) {
            outDirectory = outDirectory.slice(1);
        }
        const globalLoadPyodide = options.globalLoadPyodide || false;
        const pyodidePackagePath = tryGetPyodidePath(options.pyodideDependencyPath);
        const pkg = tryResolvePyodidePackage(pyodidePackagePath, options.version);
        options.patterns = patterns.chooseAndTransform(pkg, options.packageIndexUrl).map((pattern) => {
            return {
                from: path_1.default.resolve(pyodidePackagePath, pattern.from),
                to: path_1.default.join(outDirectory, pattern.to),
                transform: pattern.transform,
            };
        });
        assert_1.default.ok(options.patterns.length > 0, `Unsupported version of pyodide. Must use >=${patterns.versions[0]}`);
        // we have to delete all pyodide plugin options before calling super. Rest of options passed to copy webpack plugin
        delete options.packageIndexUrl;
        delete options.globalLoadPyodide;
        delete options.outDirectory;
        delete options.version;
        delete options.pyodideDependencyPath;
        super(options);
        this.globalLoadPyodide = globalLoadPyodide;
    }
    apply(compiler) {
        super.apply(compiler);
        compiler.hooks.compilation.tap(this.constructor.name, (compilation) => {
            const compilationHooks = webpack_1.default.NormalModule.getCompilationHooks(compilation);
            compilationHooks.beforeLoaders.tap(this.constructor.name, (loaders, normalModule) => {
                const matches = normalModule.userRequest.match(/pyodide\.m?js$/);
                if (matches) {
                    // add a new loader specifically to handle pyodide.m?js. See loader.ts for functionalidy
                    loaders.push({
                        loader: path_1.default.resolve(dirname, "loader.cjs"),
                        options: {
                            globalLoadPyodide: this.globalLoadPyodide,
                            isModule: matches[0].endsWith(".mjs"),
                        },
                        ident: "pyodide",
                        type: null,
                    });
                }
            });
        });
    }
}
exports.PyodidePlugin = PyodidePlugin;
/**
 * Try to find the pyodide path. Can't use require.resolve because it is not supported in
 * module builds. Nodes import.meta.resolve is experimental and still very new as of node 19.x
 * This method is works universally under the assumption of an install in node_modules/pyodide
 * @param pyodidePath
 * @returns
 */
function tryGetPyodidePath(pyodidePath) {
    if (pyodidePath) {
        return path_1.default.resolve(pyodidePath);
    }
    let pyodideEntrypoint = "";
    if (true) {
        try {
            pyodideEntrypoint = require.resolve("pyodide");
        }
        catch (e) {
            noop(e);
        }
    }
    else {}
    const walk = (p) => {
        const stat = fs_1.default.statSync(p);
        if (stat.isFile()) {
            return walk(path_1.default.dirname(p));
        }
        if (stat.isDirectory()) {
            if (path_1.default.basename(p) === "node_modules") {
                throw new Error("unable to locate pyodide package. You can define it manually with pyodidePath if you're trying to test something novel");
            }
            for (const dirent of fs_1.default.readdirSync(p, { withFileTypes: true })) {
                if (dirent.name !== "package.json" || dirent.isDirectory()) {
                    continue;
                }
                try {
                    const pkg = fs_1.default.readFileSync(path_1.default.join(p, dirent.name), "utf-8");
                    const pkgJson = JSON.parse(pkg);
                    if (pkgJson.name === "pyodide") {
                        // found pyodide package root. Exit this thing
                        return p;
                    }
                }
                catch (e) {
                    throw new Error("unable to locate and parse pyodide package.json. You can define it manually with pyodidePath if you're trying to test something novel");
                }
            }
            return walk(path_1.default.dirname(p));
        }
    };
    return walk(pyodideEntrypoint);
}
/**
 * Read the pyodide package dependency package.json to return necessary metadata
 * @param version
 * @returns
 */
function tryResolvePyodidePackage(pyodidePath, version) {
    if (version) {
        return { version };
    }
    const pkgPath = path_1.default.resolve(pyodidePath, "package.json");
    try {
        const pkg = fs_1.default.readFileSync(pkgPath, "utf-8");
        return JSON.parse(pkg);
    }
    catch (e) {
        throw new Error(`unable to read package.json from pyodide dependency in ${pkgPath}`);
    }
}
exports["default"] = PyodidePlugin;


/***/ }),

/***/ "copy-webpack-plugin":
/*!**************************************!*\
  !*** external "copy-webpack-plugin" ***!
  \**************************************/
/***/ ((module) => {

module.exports = require("copy-webpack-plugin");

/***/ }),

/***/ "webpack":
/*!**************************!*\
  !*** external "webpack" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("webpack");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("assert");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "node:module":
/*!******************************!*\
  !*** external "node:module" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:module");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsUUFBUTtBQUMxRjtBQUNBO0FBQ0Esa0JBQWU7Ozs7Ozs7Ozs7O0FDOUtmOzs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7QUNBQTs7Ozs7O1VDQUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7OztVRXRCQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1B5b2RpZGVQbHVnaW4vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1B5b2RpZGVQbHVnaW4vLi9saWIvcGF0dGVybnMudHMiLCJ3ZWJwYWNrOi8vUHlvZGlkZVBsdWdpbi8uL2luZGV4LnRzIiwid2VicGFjazovL1B5b2RpZGVQbHVnaW4vZXh0ZXJuYWwgY29tbW9uanMgXCJjb3B5LXdlYnBhY2stcGx1Z2luXCIiLCJ3ZWJwYWNrOi8vUHlvZGlkZVBsdWdpbi9leHRlcm5hbCBjb21tb25qcyBcIndlYnBhY2tcIiIsIndlYnBhY2s6Ly9QeW9kaWRlUGx1Z2luL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJhc3NlcnRcIiIsIndlYnBhY2s6Ly9QeW9kaWRlUGx1Z2luL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJmc1wiIiwid2VicGFjazovL1B5b2RpZGVQbHVnaW4vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5vZGU6bW9kdWxlXCIiLCJ3ZWJwYWNrOi8vUHlvZGlkZVBsdWdpbi9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwicGF0aFwiIiwid2VicGFjazovL1B5b2RpZGVQbHVnaW4vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vUHlvZGlkZVBsdWdpbi93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL1B5b2RpZGVQbHVnaW4vd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL1B5b2RpZGVQbHVnaW4vd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiUHlvZGlkZVBsdWdpblwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJQeW9kaWRlUGx1Z2luXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlB5b2RpZGVQbHVnaW5cIl0gPSBmYWN0b3J5KCk7XG59KSgodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpLCAoKSA9PiB7XG5yZXR1cm4gIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNob29zZUFuZFRyYW5zZm9ybSA9IGV4cG9ydHMudHJhbnNmb3JtID0gZXhwb3J0cy5jaG9vc2UgPSBleHBvcnRzLnZlcnNpb25zID0gdm9pZCAwO1xuY29uc3QgZmlsZXMgPSB7XG4gICAgXCIwLjIxLjNcIjogW1xuICAgICAgICBcImRpc3R1dGlscy50YXJcIixcbiAgICAgICAgXCJwYWNrYWdlLmpzb25cIixcbiAgICAgICAgXCJweW9kaWRlX3B5LnRhclwiLFxuICAgICAgICBcInB5b2RpZGUuYXNtLmpzXCIsXG4gICAgICAgIFwicHlvZGlkZS5hc20uanNcIixcbiAgICAgICAgXCJweW9kaWRlLmFzbS5kYXRhXCIsXG4gICAgICAgIFwicHlvZGlkZS5hc20ud2FzbVwiLFxuICAgICAgICBcInJlcG9kYXRhLmpzb25cIixcbiAgICBdLFxuICAgIFwiMC4yMi4xXCI6IFtcbiAgICAgICAgXCJwYWNrYWdlLmpzb25cIixcbiAgICAgICAgXCJweW9kaWRlX3B5LnRhclwiLFxuICAgICAgICBcInB5b2RpZGUuYXNtLmpzXCIsXG4gICAgICAgIFwicHlvZGlkZS5hc20uZGF0YVwiLFxuICAgICAgICBcInB5b2RpZGUuYXNtLndhc21cIixcbiAgICAgICAgXCJyZXBvZGF0YS5qc29uXCIsXG4gICAgXSxcbiAgICBcIjAuMjMuMFwiOiBbXCJwYWNrYWdlLmpzb25cIiwgXCJweW9kaWRlLmFzbS5qc1wiLCBcInB5b2RpZGUuYXNtLndhc21cIiwgXCJyZXBvZGF0YS5qc29uXCIsIFwicHl0aG9uX3N0ZGxpYi56aXBcIl0sXG4gICAgXCIwLjI0LjBcIjogZnVuY3Rpb24gKHBrZykge1xuICAgICAgICBpZiAoIXBrZy5maWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxpc3Qgb2YgZmlsZXMgdG8gaWdub3JlXG4gICAgICAgIGNvbnN0IGlnbm9yZSA9IFsvXnB5b2RpZGUubT9qcy4qLywgLy4rXFwuZFxcLnRzJC8sIC8uK1xcLmh0bWwkL107XG4gICAgICAgIC8vIGZpbGVzIHRvIGVuc3VyZSBhcmUgYWx3YXlzIGluY2x1ZGVkXG4gICAgICAgIGNvbnN0IGFsd2F5cyA9IFtcInBhY2thZ2UuanNvblwiXTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBwa2cuZmlsZXMuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIWlnbm9yZS5zb21lKCh2KSA9PiBmaWxlLm1hdGNoKHYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFsd2F5cy5mb3JFYWNoKChmKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlcmVkLmluY2x1ZGVzKGYpKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaChmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgICB9LFxufTtcbmV4cG9ydHMudmVyc2lvbnMgPSBPYmplY3Qua2V5cyhmaWxlcyk7XG4vKipcbiAqIENob29zZSB0aGUgc2V0IG9mIGZpbGVzIHRvIG1hdGNoIGZvciBjb3B5aW5nIG91dCBvZiBweW9kaWRlLlxuICogQmFzZWQgb24gdGhlIHZlcnNpb24gcGFzc2VkLiBJZiBubyB2ZXJzaW9uIGlzIGF2YWlsYWJsZSBpbiBmaWxlcyB0byBtYXRjaFxuICogdGhhdCBpcyBncmVhdCBlbm91Z2ggYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0gdmVyc2lvblxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG5mdW5jdGlvbiBjaG9vc2UodmVyc2lvbiA9IFwiMC4wLjBcIikge1xuICAgIGxldCBjaG9zZW4gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cG9ydHMudmVyc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPj0gZXhwb3J0cy52ZXJzaW9uc1tpXSkge1xuICAgICAgICAgICAgY2hvc2VuID0gZmlsZXNbZXhwb3J0cy52ZXJzaW9uc1tpXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNob3Nlbjtcbn1cbmV4cG9ydHMuY2hvb3NlID0gY2hvb3NlO1xuLyoqXG4gKiBDaG9vc2UgdGhlIHNldCBvZiBmaWxlcyB0byBtYXRjaCBmb3IgY29weWluZyBvdXQgb2YgcHlvZGlkZS5cbiAqIEJhc2VkIG9uIHRoZSB2ZXJzaW9uIHBhc3NlZC4gSWYgbm8gdmVyc2lvbiBpcyBhdmFpbGFibGUgaW4gZmlsZXMgdG8gbWF0Y2hcbiAqIHRoYXQgaXMgZ3JlYXQgZW5vdWdoIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuICogQHBhcmFtIHZlcnNpb25cbiAqIEBwYXJhbSBwYXR0ZXJuXG4gKiBAcGFyYW0gcGFja2FnZUluZGV4VXJsXG4gKiBAcmV0dXJucyB7UHlvZGlkZU9iamVjdFBhdHRlcm5bXX1cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtKHZlcnNpb24sIHBhdHRlcm4sIHBhY2thZ2VJbmRleFVybCkge1xuICAgIHJldHVybiBwYXR0ZXJuLm1hcCgobmFtZSkgPT4ge1xuICAgICAgICBsZXQgdHJhbnNmb3JtO1xuICAgICAgICBpZiAocGFja2FnZUluZGV4VXJsICYmIG5hbWUgPT0gXCJweW9kaWRlLmFzbS5qc1wiKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZXI6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcInJlc29sdmVQYXRoKGZpbGVfbmFtZSxBUEkuY29uZmlnLmluZGV4VVJMKVwiLCBgcmVzb2x2ZVBhdGgoZmlsZV9uYW1lLFwiJHtwYWNrYWdlSW5kZXhVcmx9XCIpYCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJvbTogbmFtZSwgdG86IG5hbWUsIHRyYW5zZm9ybSB9O1xuICAgIH0pO1xufVxuZXhwb3J0cy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5mdW5jdGlvbiBjaG9vc2VBbmRUcmFuc2Zvcm0ocGtnLCBwYWNrYWdlSW5kZXhVcmwpIHtcbiAgICBwYWNrYWdlSW5kZXhVcmwgPSBwYWNrYWdlSW5kZXhVcmwgIT09IG51bGwgJiYgcGFja2FnZUluZGV4VXJsICE9PSB2b2lkIDAgPyBwYWNrYWdlSW5kZXhVcmwgOiBgaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L3B5b2RpZGUvdiR7cGtnLnZlcnNpb259L2Z1bGwvYDtcbiAgICBsZXQgZmlsZXMgPSBjaG9vc2UocGtnLnZlcnNpb24pO1xuICAgIGlmICh0eXBlb2YgZmlsZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBmaWxlcyA9IGZpbGVzKHBrZyk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm0ocGtnLnZlcnNpb24sIGZpbGVzLCBwYWNrYWdlSW5kZXhVcmwpO1xufVxuZXhwb3J0cy5jaG9vc2VBbmRUcmFuc2Zvcm0gPSBjaG9vc2VBbmRUcmFuc2Zvcm07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QeW9kaWRlUGx1Z2luID0gdm9pZCAwO1xuY29uc3QgZnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZnNcIikpO1xuY29uc3QgYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBwYXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBhdGhcIikpO1xuY29uc3QgY29weV93ZWJwYWNrX3BsdWdpbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjb3B5LXdlYnBhY2stcGx1Z2luXCIpKTtcbmNvbnN0IHdlYnBhY2tfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwid2VicGFja1wiKSk7XG5jb25zdCBwYXR0ZXJucyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvcGF0dGVybnNcIikpO1xuY29uc3Qgbm9kZV9tb2R1bGVfMSA9IHJlcXVpcmUoXCJub2RlOm1vZHVsZVwiKTtcbmZ1bmN0aW9uIG5vb3AoXykge1xuICAgIHJldHVybiBfO1xufVxubGV0IGRpcm5hbWU7XG50cnkge1xuICAgIC8vIEB0cy1pZ25vcmUgaW1wb3J0Lm1ldGEgaXMgb25seSBhdmFpbGFibGUgaW4gZXNtLi4uXG4gICAgZGlybmFtZSA9IF9fZGlybmFtZTtcbn1cbmNhdGNoIChlKSB7XG4gICAgbm9vcChlKTtcbn1cbmNsYXNzIFB5b2RpZGVQbHVnaW4gZXh0ZW5kcyBjb3B5X3dlYnBhY2tfcGx1Z2luXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBvdXREaXJlY3RvcnkgPSBvcHRpb25zLm91dERpcmVjdG9yeSB8fCBcInB5b2RpZGVcIjtcbiAgICAgICAgaWYgKG91dERpcmVjdG9yeS5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgb3V0RGlyZWN0b3J5ID0gb3V0RGlyZWN0b3J5LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdsb2JhbExvYWRQeW9kaWRlID0gb3B0aW9ucy5nbG9iYWxMb2FkUHlvZGlkZSB8fCBmYWxzZTtcbiAgICAgICAgY29uc3QgcHlvZGlkZVBhY2thZ2VQYXRoID0gdHJ5R2V0UHlvZGlkZVBhdGgob3B0aW9ucy5weW9kaWRlRGVwZW5kZW5jeVBhdGgpO1xuICAgICAgICBjb25zdCBwa2cgPSB0cnlSZXNvbHZlUHlvZGlkZVBhY2thZ2UocHlvZGlkZVBhY2thZ2VQYXRoLCBvcHRpb25zLnZlcnNpb24pO1xuICAgICAgICBvcHRpb25zLnBhdHRlcm5zID0gcGF0dGVybnMuY2hvb3NlQW5kVHJhbnNmb3JtKHBrZywgb3B0aW9ucy5wYWNrYWdlSW5kZXhVcmwpLm1hcCgocGF0dGVybikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBwYXRoXzEuZGVmYXVsdC5yZXNvbHZlKHB5b2RpZGVQYWNrYWdlUGF0aCwgcGF0dGVybi5mcm9tKSxcbiAgICAgICAgICAgICAgICB0bzogcGF0aF8xLmRlZmF1bHQuam9pbihvdXREaXJlY3RvcnksIHBhdHRlcm4udG8pLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogcGF0dGVybi50cmFuc2Zvcm0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdC5vayhvcHRpb25zLnBhdHRlcm5zLmxlbmd0aCA+IDAsIGBVbnN1cHBvcnRlZCB2ZXJzaW9uIG9mIHB5b2RpZGUuIE11c3QgdXNlID49JHtwYXR0ZXJucy52ZXJzaW9uc1swXX1gKTtcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBkZWxldGUgYWxsIHB5b2RpZGUgcGx1Z2luIG9wdGlvbnMgYmVmb3JlIGNhbGxpbmcgc3VwZXIuIFJlc3Qgb2Ygb3B0aW9ucyBwYXNzZWQgdG8gY29weSB3ZWJwYWNrIHBsdWdpblxuICAgICAgICBkZWxldGUgb3B0aW9ucy5wYWNrYWdlSW5kZXhVcmw7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmdsb2JhbExvYWRQeW9kaWRlO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5vdXREaXJlY3Rvcnk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnZlcnNpb247XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnB5b2RpZGVEZXBlbmRlbmN5UGF0aDtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ2xvYmFsTG9hZFB5b2RpZGUgPSBnbG9iYWxMb2FkUHlvZGlkZTtcbiAgICB9XG4gICAgYXBwbHkoY29tcGlsZXIpIHtcbiAgICAgICAgc3VwZXIuYXBwbHkoY29tcGlsZXIpO1xuICAgICAgICBjb21waWxlci5ob29rcy5jb21waWxhdGlvbi50YXAodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAoY29tcGlsYXRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBpbGF0aW9uSG9va3MgPSB3ZWJwYWNrXzEuZGVmYXVsdC5Ob3JtYWxNb2R1bGUuZ2V0Q29tcGlsYXRpb25Ib29rcyhjb21waWxhdGlvbik7XG4gICAgICAgICAgICBjb21waWxhdGlvbkhvb2tzLmJlZm9yZUxvYWRlcnMudGFwKHRoaXMuY29uc3RydWN0b3IubmFtZSwgKGxvYWRlcnMsIG5vcm1hbE1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBub3JtYWxNb2R1bGUudXNlclJlcXVlc3QubWF0Y2goL3B5b2RpZGVcXC5tP2pzJC8pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldyBsb2FkZXIgc3BlY2lmaWNhbGx5IHRvIGhhbmRsZSBweW9kaWRlLm0/anMuIFNlZSBsb2FkZXIudHMgZm9yIGZ1bmN0aW9uYWxpZHlcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlcjogcGF0aF8xLmRlZmF1bHQucmVzb2x2ZShkaXJuYW1lLCBcImxvYWRlci5janNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsTG9hZFB5b2RpZGU6IHRoaXMuZ2xvYmFsTG9hZFB5b2RpZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNNb2R1bGU6IG1hdGNoZXNbMF0uZW5kc1dpdGgoXCIubWpzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50OiBcInB5b2RpZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlB5b2RpZGVQbHVnaW4gPSBQeW9kaWRlUGx1Z2luO1xuLyoqXG4gKiBUcnkgdG8gZmluZCB0aGUgcHlvZGlkZSBwYXRoLiBDYW4ndCB1c2UgcmVxdWlyZS5yZXNvbHZlIGJlY2F1c2UgaXQgaXMgbm90IHN1cHBvcnRlZCBpblxuICogbW9kdWxlIGJ1aWxkcy4gTm9kZXMgaW1wb3J0Lm1ldGEucmVzb2x2ZSBpcyBleHBlcmltZW50YWwgYW5kIHN0aWxsIHZlcnkgbmV3IGFzIG9mIG5vZGUgMTkueFxuICogVGhpcyBtZXRob2QgaXMgd29ya3MgdW5pdmVyc2FsbHkgdW5kZXIgdGhlIGFzc3VtcHRpb24gb2YgYW4gaW5zdGFsbCBpbiBub2RlX21vZHVsZXMvcHlvZGlkZVxuICogQHBhcmFtIHB5b2RpZGVQYXRoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB0cnlHZXRQeW9kaWRlUGF0aChweW9kaWRlUGF0aCkge1xuICAgIGlmIChweW9kaWRlUGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aF8xLmRlZmF1bHQucmVzb2x2ZShweW9kaWRlUGF0aCk7XG4gICAgfVxuICAgIGxldCBweW9kaWRlRW50cnlwb2ludCA9IFwiXCI7XG4gICAgaWYgKHR5cGVvZiByZXF1aXJlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBweW9kaWRlRW50cnlwb2ludCA9IF9fbm9uX3dlYnBhY2tfcmVxdWlyZV9fLnJlc29sdmUoXCJweW9kaWRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBub29wKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpbXBvcnQubWV0YSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBlc20uLi5cbiAgICAgICAgICAgIGNvbnN0IHIgPSAoMCwgbm9kZV9tb2R1bGVfMS5jcmVhdGVSZXF1aXJlKShpbXBvcnQubWV0YS51cmwpO1xuICAgICAgICAgICAgcHlvZGlkZUVudHJ5cG9pbnQgPSByLnJlc29sdmUoXCJweW9kaWRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBub29wKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdhbGsgPSAocCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ID0gZnNfMS5kZWZhdWx0LnN0YXRTeW5jKHApO1xuICAgICAgICBpZiAoc3RhdC5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGsocGF0aF8xLmRlZmF1bHQuZGlybmFtZShwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgaWYgKHBhdGhfMS5kZWZhdWx0LmJhc2VuYW1lKHApID09PSBcIm5vZGVfbW9kdWxlc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIGxvY2F0ZSBweW9kaWRlIHBhY2thZ2UuIFlvdSBjYW4gZGVmaW5lIGl0IG1hbnVhbGx5IHdpdGggcHlvZGlkZVBhdGggaWYgeW91J3JlIHRyeWluZyB0byB0ZXN0IHNvbWV0aGluZyBub3ZlbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZGlyZW50IG9mIGZzXzEuZGVmYXVsdC5yZWFkZGlyU3luYyhwLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZW50Lm5hbWUgIT09IFwicGFja2FnZS5qc29uXCIgfHwgZGlyZW50LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBrZyA9IGZzXzEuZGVmYXVsdC5yZWFkRmlsZVN5bmMocGF0aF8xLmRlZmF1bHQuam9pbihwLCBkaXJlbnQubmFtZSksIFwidXRmLThcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBrZ0pzb24gPSBKU09OLnBhcnNlKHBrZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwa2dKc29uLm5hbWUgPT09IFwicHlvZGlkZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBweW9kaWRlIHBhY2thZ2Ugcm9vdC4gRXhpdCB0aGlzIHRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gbG9jYXRlIGFuZCBwYXJzZSBweW9kaWRlIHBhY2thZ2UuanNvbi4gWW91IGNhbiBkZWZpbmUgaXQgbWFudWFsbHkgd2l0aCBweW9kaWRlUGF0aCBpZiB5b3UncmUgdHJ5aW5nIHRvIHRlc3Qgc29tZXRoaW5nIG5vdmVsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3YWxrKHBhdGhfMS5kZWZhdWx0LmRpcm5hbWUocCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gd2FsayhweW9kaWRlRW50cnlwb2ludCk7XG59XG4vKipcbiAqIFJlYWQgdGhlIHB5b2RpZGUgcGFja2FnZSBkZXBlbmRlbmN5IHBhY2thZ2UuanNvbiB0byByZXR1cm4gbmVjZXNzYXJ5IG1ldGFkYXRhXG4gKiBAcGFyYW0gdmVyc2lvblxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdHJ5UmVzb2x2ZVB5b2RpZGVQYWNrYWdlKHB5b2RpZGVQYXRoLCB2ZXJzaW9uKSB7XG4gICAgaWYgKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgdmVyc2lvbiB9O1xuICAgIH1cbiAgICBjb25zdCBwa2dQYXRoID0gcGF0aF8xLmRlZmF1bHQucmVzb2x2ZShweW9kaWRlUGF0aCwgXCJwYWNrYWdlLmpzb25cIik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGtnID0gZnNfMS5kZWZhdWx0LnJlYWRGaWxlU3luYyhwa2dQYXRoLCBcInV0Zi04XCIpO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShwa2cpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byByZWFkIHBhY2thZ2UuanNvbiBmcm9tIHB5b2RpZGUgZGVwZW5kZW5jeSBpbiAke3BrZ1BhdGh9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUHlvZGlkZVBsdWdpbjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcHktd2VicGFjay1wbHVnaW5cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwid2VicGFja1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhc3NlcnRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibm9kZTptb2R1bGVcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==