(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("pyodide-webpack-loader", [], factory);
	else if(typeof exports === 'object')
		exports["pyodide-webpack-loader"] = factory();
	else
		root["pyodide-webpack-loader"] = factory();
})((typeof self !== 'undefined' ? self : this), () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./loader.ts":
/*!*******************!*\
  !*** ./loader.ts ***!
  \*******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const acorn_1 = __webpack_require__(/*! acorn */ "acorn");
const acorn_import_assertions_1 = __webpack_require__(/*! acorn-import-assertions */ "acorn-import-assertions");
const esbuild_1 = __importDefault(__webpack_require__(/*! esbuild */ "esbuild"));
const walk = __webpack_require__(/*! acorn-walk */ "acorn-walk");
const parser = acorn_1.Parser.extend(acorn_import_assertions_1.importAssertions);
class PyodideParser {
    constructor(source, options) {
        this.delta = 0;
        this.ast = parser.parse(source, {
            ecmaVersion: 2020,
            sourceType: options.isModule ? "module" : "script",
        });
        this.options = options;
        this.source = source;
    }
    parse() {
        // eslint-disable-next-line
        const self = this;
        walk.simple(this.ast, {
            ExpressionStatement(node) {
                self.walkExpressionStatement(node);
            },
        });
    }
    replace(statement, str) {
        const len = statement.end - statement.start;
        const start = this.source.slice(0, statement.start + this.delta);
        const end = this.source.slice(statement.end + this.delta);
        this.source = `${start}${str}${end}`;
        this.delta += str.length - len;
        return str;
    }
    walkExpressionStatement(statement) {
        var _a, _b;
        // getting dumb here. Just want to do some quick things.
        if (this.options.globalLoadPyodide) {
            return;
        }
        const assignment = (_b = (_a = statement.expression) === null || _a === void 0 ? void 0 : _a.left) === null || _b === void 0 ? void 0 : _b.object;
        if ((assignment === null || assignment === void 0 ? void 0 : assignment.type) !== "Identifier" || (assignment === null || assignment === void 0 ? void 0 : assignment.name) !== "globalThis") {
            return;
        }
        // remove global load pyodide
        this.replace(statement, "({});");
    }
}
function addNamedExports(source, options) {
    // convoluted way to inject exports. In the future if this
    // gets too complicated opt for a js compiler that can take in
    // estree AST and manipulate the AST tree directly instead.
    // for now though this works and keeps dependencies down to a minimum
    if (options.isModule) {
        // esm module already has exports like we expect
        return source;
    }
    const newSource = source.split("\n");
    const commonExports = "module.exports = {loadPyodide: loadPyodide.loadPyodide, version: loadPyodide.version};";
    for (let i = 0; i < newSource.length; i++) {
        if (!newSource[i].includes("sourceMappingURL"))
            continue;
        newSource.splice(i, 0, commonExports);
        break;
    }
    return newSource.join("\n");
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function fc(v) {
    return v;
}
function default_1(source) {
    // @ts-expect-error this has a type any, but we know this is a loader context
    const self = fc(this);
    const options = self.getOptions();
    let banner = "module.exports =";
    let footer = "";
    if (options.isModule) {
        source = esbuild_1.default.transformSync(source, {
            banner: "const module={exports:{}};",
            footer: "module.exports;",
            format: "cjs",
        }).code;
        banner = "const out =";
        // not sure how to make this better. Need some way to dynamically export these but esm provides no way
        footer = "export const loadPyodide = out.loadPyodide;\nexport const version = out.version;";
    }
    // this._module.parser.state.module = this._module;
    // parse with the original parser... causes errors because we do not want this to
    // actually be evaluated and added to webpack's tree
    // const ast = this._module.parser.parse(source, {
    //   module: this._module,
    //   current: this._module,
    //   options: {},
    //   source: source
    // });
    // parse with our own parser
    const p = new PyodideParser(source, options);
    p.parse();
    const finalSource = addNamedExports(p.source, options);
    return `${banner} eval(${JSON.stringify(finalSource)});\n${footer}`;
}
exports["default"] = default_1;


/***/ }),

/***/ "acorn":
/*!************************!*\
  !*** external "acorn" ***!
  \************************/
/***/ ((module) => {

module.exports = require("acorn");

/***/ }),

/***/ "acorn-import-assertions":
/*!******************************************!*\
  !*** external "acorn-import-assertions" ***!
  \******************************************/
/***/ ((module) => {

module.exports = require("acorn-import-assertions");

/***/ }),

/***/ "acorn-walk":
/*!*****************************!*\
  !*** external "acorn-walk" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("acorn-walk");

/***/ }),

/***/ "esbuild":
/*!**************************!*\
  !*** external "esbuild" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("esbuild");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./loader.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZGVyLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7OztBQ1ZhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsb0JBQU87QUFDL0Isa0NBQWtDLG1CQUFPLENBQUMsd0RBQXlCO0FBQ25FLGtDQUFrQyxtQkFBTyxDQUFDLHdCQUFTO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQyw4QkFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0VBQW9FO0FBQ2pILG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQyxvQ0FBb0M7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDZEQUE2RCxxQ0FBcUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVEsT0FBTyw0QkFBNEIsRUFBRSxJQUFJLE9BQU87QUFDdEU7QUFDQSxrQkFBZTs7Ozs7Ozs7Ozs7QUN6R2Y7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7O0FDQUE7Ozs7OztVQ0FBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7VUV0QkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9weW9kaWRlLXdlYnBhY2stbG9hZGVyL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9weW9kaWRlLXdlYnBhY2stbG9hZGVyLy4vbG9hZGVyLnRzIiwid2VicGFjazovL3B5b2RpZGUtd2VicGFjay1sb2FkZXIvZXh0ZXJuYWwgY29tbW9uanMgXCJhY29yblwiIiwid2VicGFjazovL3B5b2RpZGUtd2VicGFjay1sb2FkZXIvZXh0ZXJuYWwgY29tbW9uanMgXCJhY29ybi1pbXBvcnQtYXNzZXJ0aW9uc1wiIiwid2VicGFjazovL3B5b2RpZGUtd2VicGFjay1sb2FkZXIvZXh0ZXJuYWwgY29tbW9uanMgXCJhY29ybi13YWxrXCIiLCJ3ZWJwYWNrOi8vcHlvZGlkZS13ZWJwYWNrLWxvYWRlci9leHRlcm5hbCBjb21tb25qcyBcImVzYnVpbGRcIiIsIndlYnBhY2s6Ly9weW9kaWRlLXdlYnBhY2stbG9hZGVyL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3B5b2RpZGUtd2VicGFjay1sb2FkZXIvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9weW9kaWRlLXdlYnBhY2stbG9hZGVyL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9weW9kaWRlLXdlYnBhY2stbG9hZGVyL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcInB5b2RpZGUtd2VicGFjay1sb2FkZXJcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicHlvZGlkZS13ZWJwYWNrLWxvYWRlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJweW9kaWRlLXdlYnBhY2stbG9hZGVyXCJdID0gZmFjdG9yeSgpO1xufSkoKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKSwgKCkgPT4ge1xucmV0dXJuICIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYWNvcm5fMSA9IHJlcXVpcmUoXCJhY29yblwiKTtcbmNvbnN0IGFjb3JuX2ltcG9ydF9hc3NlcnRpb25zXzEgPSByZXF1aXJlKFwiYWNvcm4taW1wb3J0LWFzc2VydGlvbnNcIik7XG5jb25zdCBlc2J1aWxkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImVzYnVpbGRcIikpO1xuY29uc3Qgd2FsayA9IHJlcXVpcmUoXCJhY29ybi13YWxrXCIpO1xuY29uc3QgcGFyc2VyID0gYWNvcm5fMS5QYXJzZXIuZXh0ZW5kKGFjb3JuX2ltcG9ydF9hc3NlcnRpb25zXzEuaW1wb3J0QXNzZXJ0aW9ucyk7XG5jbGFzcyBQeW9kaWRlUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kZWx0YSA9IDA7XG4gICAgICAgIHRoaXMuYXN0ID0gcGFyc2VyLnBhcnNlKHNvdXJjZSwge1xuICAgICAgICAgICAgZWNtYVZlcnNpb246IDIwMjAsXG4gICAgICAgICAgICBzb3VyY2VUeXBlOiBvcHRpb25zLmlzTW9kdWxlID8gXCJtb2R1bGVcIiA6IFwic2NyaXB0XCIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgcGFyc2UoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgd2Fsay5zaW1wbGUodGhpcy5hc3QsIHtcbiAgICAgICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICAgICAgICAgIHNlbGYud2Fsa0V4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVwbGFjZShzdGF0ZW1lbnQsIHN0cikge1xuICAgICAgICBjb25zdCBsZW4gPSBzdGF0ZW1lbnQuZW5kIC0gc3RhdGVtZW50LnN0YXJ0O1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuc291cmNlLnNsaWNlKDAsIHN0YXRlbWVudC5zdGFydCArIHRoaXMuZGVsdGEpO1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLnNvdXJjZS5zbGljZShzdGF0ZW1lbnQuZW5kICsgdGhpcy5kZWx0YSk7XG4gICAgICAgIHRoaXMuc291cmNlID0gYCR7c3RhcnR9JHtzdHJ9JHtlbmR9YDtcbiAgICAgICAgdGhpcy5kZWx0YSArPSBzdHIubGVuZ3RoIC0gbGVuO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICB3YWxrRXhwcmVzc2lvblN0YXRlbWVudChzdGF0ZW1lbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gZ2V0dGluZyBkdW1iIGhlcmUuIEp1c3Qgd2FudCB0byBkbyBzb21lIHF1aWNrIHRoaW5ncy5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5nbG9iYWxMb2FkUHlvZGlkZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSAoX2IgPSAoX2EgPSBzdGF0ZW1lbnQuZXhwcmVzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlZnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vYmplY3Q7XG4gICAgICAgIGlmICgoYXNzaWdubWVudCA9PT0gbnVsbCB8fCBhc3NpZ25tZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhc3NpZ25tZW50LnR5cGUpICE9PSBcIklkZW50aWZpZXJcIiB8fCAoYXNzaWdubWVudCA9PT0gbnVsbCB8fCBhc3NpZ25tZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhc3NpZ25tZW50Lm5hbWUpICE9PSBcImdsb2JhbFRoaXNcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBnbG9iYWwgbG9hZCBweW9kaWRlXG4gICAgICAgIHRoaXMucmVwbGFjZShzdGF0ZW1lbnQsIFwiKHt9KTtcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkTmFtZWRFeHBvcnRzKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIC8vIGNvbnZvbHV0ZWQgd2F5IHRvIGluamVjdCBleHBvcnRzLiBJbiB0aGUgZnV0dXJlIGlmIHRoaXNcbiAgICAvLyBnZXRzIHRvbyBjb21wbGljYXRlZCBvcHQgZm9yIGEganMgY29tcGlsZXIgdGhhdCBjYW4gdGFrZSBpblxuICAgIC8vIGVzdHJlZSBBU1QgYW5kIG1hbmlwdWxhdGUgdGhlIEFTVCB0cmVlIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgLy8gZm9yIG5vdyB0aG91Z2ggdGhpcyB3b3JrcyBhbmQga2VlcHMgZGVwZW5kZW5jaWVzIGRvd24gdG8gYSBtaW5pbXVtXG4gICAgaWYgKG9wdGlvbnMuaXNNb2R1bGUpIHtcbiAgICAgICAgLy8gZXNtIG1vZHVsZSBhbHJlYWR5IGhhcyBleHBvcnRzIGxpa2Ugd2UgZXhwZWN0XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuICAgIGNvbnN0IG5ld1NvdXJjZSA9IHNvdXJjZS5zcGxpdChcIlxcblwiKTtcbiAgICBjb25zdCBjb21tb25FeHBvcnRzID0gXCJtb2R1bGUuZXhwb3J0cyA9IHtsb2FkUHlvZGlkZTogbG9hZFB5b2RpZGUubG9hZFB5b2RpZGUsIHZlcnNpb246IGxvYWRQeW9kaWRlLnZlcnNpb259O1wiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghbmV3U291cmNlW2ldLmluY2x1ZGVzKFwic291cmNlTWFwcGluZ1VSTFwiKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBuZXdTb3VyY2Uuc3BsaWNlKGksIDAsIGNvbW1vbkV4cG9ydHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG5ld1NvdXJjZS5qb2luKFwiXFxuXCIpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGZjKHYpIHtcbiAgICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRfMShzb3VyY2UpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaGFzIGEgdHlwZSBhbnksIGJ1dCB3ZSBrbm93IHRoaXMgaXMgYSBsb2FkZXIgY29udGV4dFxuICAgIGNvbnN0IHNlbGYgPSBmYyh0aGlzKTtcbiAgICBjb25zdCBvcHRpb25zID0gc2VsZi5nZXRPcHRpb25zKCk7XG4gICAgbGV0IGJhbm5lciA9IFwibW9kdWxlLmV4cG9ydHMgPVwiO1xuICAgIGxldCBmb290ZXIgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLmlzTW9kdWxlKSB7XG4gICAgICAgIHNvdXJjZSA9IGVzYnVpbGRfMS5kZWZhdWx0LnRyYW5zZm9ybVN5bmMoc291cmNlLCB7XG4gICAgICAgICAgICBiYW5uZXI6IFwiY29uc3QgbW9kdWxlPXtleHBvcnRzOnt9fTtcIixcbiAgICAgICAgICAgIGZvb3RlcjogXCJtb2R1bGUuZXhwb3J0cztcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJjanNcIixcbiAgICAgICAgfSkuY29kZTtcbiAgICAgICAgYmFubmVyID0gXCJjb25zdCBvdXQgPVwiO1xuICAgICAgICAvLyBub3Qgc3VyZSBob3cgdG8gbWFrZSB0aGlzIGJldHRlci4gTmVlZCBzb21lIHdheSB0byBkeW5hbWljYWxseSBleHBvcnQgdGhlc2UgYnV0IGVzbSBwcm92aWRlcyBubyB3YXlcbiAgICAgICAgZm9vdGVyID0gXCJleHBvcnQgY29uc3QgbG9hZFB5b2RpZGUgPSBvdXQubG9hZFB5b2RpZGU7XFxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBvdXQudmVyc2lvbjtcIjtcbiAgICB9XG4gICAgLy8gdGhpcy5fbW9kdWxlLnBhcnNlci5zdGF0ZS5tb2R1bGUgPSB0aGlzLl9tb2R1bGU7XG4gICAgLy8gcGFyc2Ugd2l0aCB0aGUgb3JpZ2luYWwgcGFyc2VyLi4uIGNhdXNlcyBlcnJvcnMgYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0aGlzIHRvXG4gICAgLy8gYWN0dWFsbHkgYmUgZXZhbHVhdGVkIGFuZCBhZGRlZCB0byB3ZWJwYWNrJ3MgdHJlZVxuICAgIC8vIGNvbnN0IGFzdCA9IHRoaXMuX21vZHVsZS5wYXJzZXIucGFyc2Uoc291cmNlLCB7XG4gICAgLy8gICBtb2R1bGU6IHRoaXMuX21vZHVsZSxcbiAgICAvLyAgIGN1cnJlbnQ6IHRoaXMuX21vZHVsZSxcbiAgICAvLyAgIG9wdGlvbnM6IHt9LFxuICAgIC8vICAgc291cmNlOiBzb3VyY2VcbiAgICAvLyB9KTtcbiAgICAvLyBwYXJzZSB3aXRoIG91ciBvd24gcGFyc2VyXG4gICAgY29uc3QgcCA9IG5ldyBQeW9kaWRlUGFyc2VyKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgcC5wYXJzZSgpO1xuICAgIGNvbnN0IGZpbmFsU291cmNlID0gYWRkTmFtZWRFeHBvcnRzKHAuc291cmNlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYCR7YmFubmVyfSBldmFsKCR7SlNPTi5zdHJpbmdpZnkoZmluYWxTb3VyY2UpfSk7XFxuJHtmb290ZXJ9YDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImFjb3JuXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImFjb3JuLWltcG9ydC1hc3NlcnRpb25zXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImFjb3JuLXdhbGtcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXNidWlsZFwiKTsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9sb2FkZXIudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=