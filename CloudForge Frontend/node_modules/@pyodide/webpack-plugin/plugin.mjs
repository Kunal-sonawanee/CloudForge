import * as __WEBPACK_EXTERNAL_MODULE_copy_webpack_plugin_c1a9f86d__ from "copy-webpack-plugin";
import * as __WEBPACK_EXTERNAL_MODULE_webpack__ from "webpack";
import { createRequire as __WEBPACK_EXTERNAL_createRequire } from "node:module";
/******/ var __webpack_modules__ = ({

/***/ "./lib/patterns.ts":
/*!*************************!*\
  !*** ./lib/patterns.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   choose: () => (/* binding */ choose),
/* harmony export */   chooseAndTransform: () => (/* binding */ chooseAndTransform),
/* harmony export */   transform: () => (/* binding */ transform),
/* harmony export */   versions: () => (/* binding */ versions)
/* harmony export */ });
const files = {
    "0.21.3": [
        "distutils.tar",
        "package.json",
        "pyodide_py.tar",
        "pyodide.asm.js",
        "pyodide.asm.js",
        "pyodide.asm.data",
        "pyodide.asm.wasm",
        "repodata.json",
    ],
    "0.22.1": [
        "package.json",
        "pyodide_py.tar",
        "pyodide.asm.js",
        "pyodide.asm.data",
        "pyodide.asm.wasm",
        "repodata.json",
    ],
    "0.23.0": ["package.json", "pyodide.asm.js", "pyodide.asm.wasm", "repodata.json", "python_stdlib.zip"],
    "0.24.0": function (pkg) {
        if (!pkg.files) {
            return [];
        }
        // list of files to ignore
        const ignore = [/^pyodide.m?js.*/, /.+\.d\.ts$/, /.+\.html$/];
        // files to ensure are always included
        const always = ["package.json"];
        const filtered = pkg.files.filter((file) => {
            return !ignore.some((v) => file.match(v));
        });
        always.forEach((f) => {
            if (!filtered.includes(f)) {
                filtered.push(f);
            }
        });
        return filtered;
    },
};
const versions = Object.keys(files);
/**
 * Choose the set of files to match for copying out of pyodide.
 * Based on the version passed. If no version is available in files to match
 * that is great enough an empty array is returned.
 * @param version
 * @returns {string[]}
 */
function choose(version = "0.0.0") {
    let chosen = [];
    for (let i = 0; i < versions.length; i++) {
        if (version >= versions[i]) {
            chosen = files[versions[i]];
        }
    }
    return chosen;
}
/**
 * Choose the set of files to match for copying out of pyodide.
 * Based on the version passed. If no version is available in files to match
 * that is great enough an empty array is returned.
 * @param version
 * @param pattern
 * @param packageIndexUrl
 * @returns {PyodideObjectPattern[]}
 */
function transform(version, pattern, packageIndexUrl) {
    return pattern.map((name) => {
        let transform;
        if (packageIndexUrl && name == "pyodide.asm.js") {
            transform = {
                transformer: (input) => {
                    return input
                        .toString()
                        .replace("resolvePath(file_name,API.config.indexURL)", `resolvePath(file_name,"${packageIndexUrl}")`);
                },
            };
        }
        return { from: name, to: name, transform };
    });
}
function chooseAndTransform(pkg, packageIndexUrl) {
    packageIndexUrl = packageIndexUrl ?? `https://cdn.jsdelivr.net/pyodide/v${pkg.version}/full/`;
    let files = choose(pkg.version);
    if (typeof files === "function") {
        files = files(pkg);
    }
    return transform(pkg.version, files, packageIndexUrl);
}


/***/ }),

/***/ "copy-webpack-plugin":
/*!**************************************!*\
  !*** external "copy-webpack-plugin" ***!
  \**************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_copy_webpack_plugin_c1a9f86d__;

/***/ }),

/***/ "webpack":
/*!**************************!*\
  !*** external "webpack" ***!
  \**************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_webpack__;

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("assert");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("path");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("url");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PyodidePlugin: () => (/* binding */ PyodidePlugin),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! url */ "url");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! assert */ "assert");
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var copy_webpack_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! copy-webpack-plugin */ "copy-webpack-plugin");
/* harmony import */ var webpack__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! webpack */ "webpack");
/* harmony import */ var _lib_patterns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/patterns */ "./lib/patterns.ts");








function noop(_) {
    return _;
}
let dirname;
try {
    // @ts-ignore import.meta is only available in esm...
    dirname = path__WEBPACK_IMPORTED_MODULE_3___default().dirname(url__WEBPACK_IMPORTED_MODULE_1___default().fileURLToPath(import.meta.url));
}
catch (e) {
    noop(e);
}
class PyodidePlugin extends copy_webpack_plugin__WEBPACK_IMPORTED_MODULE_4__["default"] {
    globalLoadPyodide;
    constructor(options = {}) {
        let outDirectory = options.outDirectory || "pyodide";
        if (outDirectory.startsWith("/")) {
            outDirectory = outDirectory.slice(1);
        }
        const globalLoadPyodide = options.globalLoadPyodide || false;
        const pyodidePackagePath = tryGetPyodidePath(options.pyodideDependencyPath);
        const pkg = tryResolvePyodidePackage(pyodidePackagePath, options.version);
        options.patterns = _lib_patterns__WEBPACK_IMPORTED_MODULE_6__.chooseAndTransform(pkg, options.packageIndexUrl).map((pattern) => {
            return {
                from: path__WEBPACK_IMPORTED_MODULE_3___default().resolve(pyodidePackagePath, pattern.from),
                to: path__WEBPACK_IMPORTED_MODULE_3___default().join(outDirectory, pattern.to),
                transform: pattern.transform,
            };
        });
        assert__WEBPACK_IMPORTED_MODULE_2___default().ok(options.patterns.length > 0, `Unsupported version of pyodide. Must use >=${_lib_patterns__WEBPACK_IMPORTED_MODULE_6__.versions[0]}`);
        // we have to delete all pyodide plugin options before calling super. Rest of options passed to copy webpack plugin
        delete options.packageIndexUrl;
        delete options.globalLoadPyodide;
        delete options.outDirectory;
        delete options.version;
        delete options.pyodideDependencyPath;
        super(options);
        this.globalLoadPyodide = globalLoadPyodide;
    }
    apply(compiler) {
        super.apply(compiler);
        compiler.hooks.compilation.tap(this.constructor.name, (compilation) => {
            const compilationHooks = webpack__WEBPACK_IMPORTED_MODULE_5__["default"].NormalModule.getCompilationHooks(compilation);
            compilationHooks.beforeLoaders.tap(this.constructor.name, (loaders, normalModule) => {
                const matches = normalModule.userRequest.match(/pyodide\.m?js$/);
                if (matches) {
                    // add a new loader specifically to handle pyodide.m?js. See loader.ts for functionalidy
                    loaders.push({
                        loader: path__WEBPACK_IMPORTED_MODULE_3___default().resolve(dirname, "loader.cjs"),
                        options: {
                            globalLoadPyodide: this.globalLoadPyodide,
                            isModule: matches[0].endsWith(".mjs"),
                        },
                        ident: "pyodide",
                        type: null,
                    });
                }
            });
        });
    }
}
/**
 * Try to find the pyodide path. Can't use require.resolve because it is not supported in
 * module builds. Nodes import.meta.resolve is experimental and still very new as of node 19.x
 * This method is works universally under the assumption of an install in node_modules/pyodide
 * @param pyodidePath
 * @returns
 */
function tryGetPyodidePath(pyodidePath) {
    if (pyodidePath) {
        return path__WEBPACK_IMPORTED_MODULE_3___default().resolve(pyodidePath);
    }
    let pyodideEntrypoint = "";
    if (true) {
        try {
            pyodideEntrypoint = __WEBPACK_EXTERNAL_createRequire(import.meta.url).resolve("pyodide");
        }
        catch (e) {
            noop(e);
        }
    }
    else {}
    const walk = (p) => {
        const stat = fs__WEBPACK_IMPORTED_MODULE_0___default().statSync(p);
        if (stat.isFile()) {
            return walk(path__WEBPACK_IMPORTED_MODULE_3___default().dirname(p));
        }
        if (stat.isDirectory()) {
            if (path__WEBPACK_IMPORTED_MODULE_3___default().basename(p) === "node_modules") {
                throw new Error("unable to locate pyodide package. You can define it manually with pyodidePath if you're trying to test something novel");
            }
            for (const dirent of fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(p, { withFileTypes: true })) {
                if (dirent.name !== "package.json" || dirent.isDirectory()) {
                    continue;
                }
                try {
                    const pkg = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(path__WEBPACK_IMPORTED_MODULE_3___default().join(p, dirent.name), "utf-8");
                    const pkgJson = JSON.parse(pkg);
                    if (pkgJson.name === "pyodide") {
                        // found pyodide package root. Exit this thing
                        return p;
                    }
                }
                catch (e) {
                    throw new Error("unable to locate and parse pyodide package.json. You can define it manually with pyodidePath if you're trying to test something novel");
                }
            }
            return walk(path__WEBPACK_IMPORTED_MODULE_3___default().dirname(p));
        }
    };
    return walk(pyodideEntrypoint);
}
/**
 * Read the pyodide package dependency package.json to return necessary metadata
 * @param version
 * @returns
 */
function tryResolvePyodidePackage(pyodidePath, version) {
    if (version) {
        return { version };
    }
    const pkgPath = path__WEBPACK_IMPORTED_MODULE_3___default().resolve(pyodidePath, "package.json");
    try {
        const pkg = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(pkgPath, "utf-8");
        return JSON.parse(pkg);
    }
    catch (e) {
        throw new Error(`unable to read package.json from pyodide dependency in ${pkgPath}`);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PyodidePlugin);

})();

var __webpack_exports__PyodidePlugin = __webpack_exports__.PyodidePlugin;
var __webpack_exports__default = __webpack_exports__["default"];
export { __webpack_exports__PyodidePlugin as PyodidePlugin, __webpack_exports__default as default };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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MUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0RBQWUsQ0FBQyxnREFBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtREFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esb0JBQW9CLG1EQUFZO0FBQ2hDO0FBQ0Esb0JBQW9CLHNEQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixRQUFRO0FBQzFGO0FBQ0E7QUFDQSxpRUFBZSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcHlvZGlkZS93ZWJwYWNrLXBsdWdpbi8uL2xpYi9wYXR0ZXJucy50cyIsIndlYnBhY2s6Ly9AcHlvZGlkZS93ZWJwYWNrLXBsdWdpbi9leHRlcm5hbCBtb2R1bGUgXCJjb3B5LXdlYnBhY2stcGx1Z2luXCIiLCJ3ZWJwYWNrOi8vQHB5b2RpZGUvd2VicGFjay1wbHVnaW4vZXh0ZXJuYWwgbW9kdWxlIFwid2VicGFja1wiIiwid2VicGFjazovL0BweW9kaWRlL3dlYnBhY2stcGx1Z2luL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJhc3NlcnRcIiIsIndlYnBhY2s6Ly9AcHlvZGlkZS93ZWJwYWNrLXBsdWdpbi9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiZnNcIiIsIndlYnBhY2s6Ly9AcHlvZGlkZS93ZWJwYWNrLXBsdWdpbi9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwicGF0aFwiIiwid2VicGFjazovL0BweW9kaWRlL3dlYnBhY2stcGx1Z2luL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJ1cmxcIiIsIndlYnBhY2s6Ly9AcHlvZGlkZS93ZWJwYWNrLXBsdWdpbi93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9AcHlvZGlkZS93ZWJwYWNrLXBsdWdpbi93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9AcHlvZGlkZS93ZWJwYWNrLXBsdWdpbi93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vQHB5b2RpZGUvd2VicGFjay1wbHVnaW4vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9AcHlvZGlkZS93ZWJwYWNrLXBsdWdpbi93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL0BweW9kaWRlL3dlYnBhY2stcGx1Z2luLy4vaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZmlsZXMgPSB7XG4gICAgXCIwLjIxLjNcIjogW1xuICAgICAgICBcImRpc3R1dGlscy50YXJcIixcbiAgICAgICAgXCJwYWNrYWdlLmpzb25cIixcbiAgICAgICAgXCJweW9kaWRlX3B5LnRhclwiLFxuICAgICAgICBcInB5b2RpZGUuYXNtLmpzXCIsXG4gICAgICAgIFwicHlvZGlkZS5hc20uanNcIixcbiAgICAgICAgXCJweW9kaWRlLmFzbS5kYXRhXCIsXG4gICAgICAgIFwicHlvZGlkZS5hc20ud2FzbVwiLFxuICAgICAgICBcInJlcG9kYXRhLmpzb25cIixcbiAgICBdLFxuICAgIFwiMC4yMi4xXCI6IFtcbiAgICAgICAgXCJwYWNrYWdlLmpzb25cIixcbiAgICAgICAgXCJweW9kaWRlX3B5LnRhclwiLFxuICAgICAgICBcInB5b2RpZGUuYXNtLmpzXCIsXG4gICAgICAgIFwicHlvZGlkZS5hc20uZGF0YVwiLFxuICAgICAgICBcInB5b2RpZGUuYXNtLndhc21cIixcbiAgICAgICAgXCJyZXBvZGF0YS5qc29uXCIsXG4gICAgXSxcbiAgICBcIjAuMjMuMFwiOiBbXCJwYWNrYWdlLmpzb25cIiwgXCJweW9kaWRlLmFzbS5qc1wiLCBcInB5b2RpZGUuYXNtLndhc21cIiwgXCJyZXBvZGF0YS5qc29uXCIsIFwicHl0aG9uX3N0ZGxpYi56aXBcIl0sXG4gICAgXCIwLjI0LjBcIjogZnVuY3Rpb24gKHBrZykge1xuICAgICAgICBpZiAoIXBrZy5maWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxpc3Qgb2YgZmlsZXMgdG8gaWdub3JlXG4gICAgICAgIGNvbnN0IGlnbm9yZSA9IFsvXnB5b2RpZGUubT9qcy4qLywgLy4rXFwuZFxcLnRzJC8sIC8uK1xcLmh0bWwkL107XG4gICAgICAgIC8vIGZpbGVzIHRvIGVuc3VyZSBhcmUgYWx3YXlzIGluY2x1ZGVkXG4gICAgICAgIGNvbnN0IGFsd2F5cyA9IFtcInBhY2thZ2UuanNvblwiXTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBwa2cuZmlsZXMuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIWlnbm9yZS5zb21lKCh2KSA9PiBmaWxlLm1hdGNoKHYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFsd2F5cy5mb3JFYWNoKChmKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlcmVkLmluY2x1ZGVzKGYpKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaChmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCB2ZXJzaW9ucyA9IE9iamVjdC5rZXlzKGZpbGVzKTtcbi8qKlxuICogQ2hvb3NlIHRoZSBzZXQgb2YgZmlsZXMgdG8gbWF0Y2ggZm9yIGNvcHlpbmcgb3V0IG9mIHB5b2RpZGUuXG4gKiBCYXNlZCBvbiB0aGUgdmVyc2lvbiBwYXNzZWQuIElmIG5vIHZlcnNpb24gaXMgYXZhaWxhYmxlIGluIGZpbGVzIHRvIG1hdGNoXG4gKiB0aGF0IGlzIGdyZWF0IGVub3VnaCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaG9vc2UodmVyc2lvbiA9IFwiMC4wLjBcIikge1xuICAgIGxldCBjaG9zZW4gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uID49IHZlcnNpb25zW2ldKSB7XG4gICAgICAgICAgICBjaG9zZW4gPSBmaWxlc1t2ZXJzaW9uc1tpXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNob3Nlbjtcbn1cbi8qKlxuICogQ2hvb3NlIHRoZSBzZXQgb2YgZmlsZXMgdG8gbWF0Y2ggZm9yIGNvcHlpbmcgb3V0IG9mIHB5b2RpZGUuXG4gKiBCYXNlZCBvbiB0aGUgdmVyc2lvbiBwYXNzZWQuIElmIG5vIHZlcnNpb24gaXMgYXZhaWxhYmxlIGluIGZpbGVzIHRvIG1hdGNoXG4gKiB0aGF0IGlzIGdyZWF0IGVub3VnaCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB2ZXJzaW9uXG4gKiBAcGFyYW0gcGF0dGVyblxuICogQHBhcmFtIHBhY2thZ2VJbmRleFVybFxuICogQHJldHVybnMge1B5b2RpZGVPYmplY3RQYXR0ZXJuW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0odmVyc2lvbiwgcGF0dGVybiwgcGFja2FnZUluZGV4VXJsKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ubWFwKChuYW1lKSA9PiB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm07XG4gICAgICAgIGlmIChwYWNrYWdlSW5kZXhVcmwgJiYgbmFtZSA9PSBcInB5b2RpZGUuYXNtLmpzXCIpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lcjogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwicmVzb2x2ZVBhdGgoZmlsZV9uYW1lLEFQSS5jb25maWcuaW5kZXhVUkwpXCIsIGByZXNvbHZlUGF0aChmaWxlX25hbWUsXCIke3BhY2thZ2VJbmRleFVybH1cIilgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBuYW1lLCB0bzogbmFtZSwgdHJhbnNmb3JtIH07XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2hvb3NlQW5kVHJhbnNmb3JtKHBrZywgcGFja2FnZUluZGV4VXJsKSB7XG4gICAgcGFja2FnZUluZGV4VXJsID0gcGFja2FnZUluZGV4VXJsID8/IGBodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvcHlvZGlkZS92JHtwa2cudmVyc2lvbn0vZnVsbC9gO1xuICAgIGxldCBmaWxlcyA9IGNob29zZShwa2cudmVyc2lvbik7XG4gICAgaWYgKHR5cGVvZiBmaWxlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZpbGVzID0gZmlsZXMocGtnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybShwa2cudmVyc2lvbiwgZmlsZXMsIHBhY2thZ2VJbmRleFVybCk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfY29weV93ZWJwYWNrX3BsdWdpbl9jMWE5Zjg2ZF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV93ZWJwYWNrX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpKFwiYXNzZXJ0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX2NyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKShcImZzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX2NyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKShcInBhdGhcIik7IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpKFwidXJsXCIpOyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgdXJsIGZyb20gXCJ1cmxcIjtcbmltcG9ydCBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCBDb3B5UGx1Z2luIGZyb20gXCJjb3B5LXdlYnBhY2stcGx1Z2luXCI7XG5pbXBvcnQgd2VicGFjayBmcm9tIFwid2VicGFja1wiO1xuaW1wb3J0ICogYXMgcGF0dGVybnMgZnJvbSBcIi4vbGliL3BhdHRlcm5zXCI7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSBcIm5vZGU6bW9kdWxlXCI7XG5mdW5jdGlvbiBub29wKF8pIHtcbiAgICByZXR1cm4gXztcbn1cbmxldCBkaXJuYW1lO1xudHJ5IHtcbiAgICAvLyBAdHMtaWdub3JlIGltcG9ydC5tZXRhIGlzIG9ubHkgYXZhaWxhYmxlIGluIGVzbS4uLlxuICAgIGRpcm5hbWUgPSBwYXRoLmRpcm5hbWUodXJsLmZpbGVVUkxUb1BhdGgoaW1wb3J0Lm1ldGEudXJsKSk7XG59XG5jYXRjaCAoZSkge1xuICAgIG5vb3AoZSk7XG59XG5leHBvcnQgY2xhc3MgUHlvZGlkZVBsdWdpbiBleHRlbmRzIENvcHlQbHVnaW4ge1xuICAgIGdsb2JhbExvYWRQeW9kaWRlO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgb3V0RGlyZWN0b3J5ID0gb3B0aW9ucy5vdXREaXJlY3RvcnkgfHwgXCJweW9kaWRlXCI7XG4gICAgICAgIGlmIChvdXREaXJlY3Rvcnkuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIG91dERpcmVjdG9yeSA9IG91dERpcmVjdG9yeS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnbG9iYWxMb2FkUHlvZGlkZSA9IG9wdGlvbnMuZ2xvYmFsTG9hZFB5b2RpZGUgfHwgZmFsc2U7XG4gICAgICAgIGNvbnN0IHB5b2RpZGVQYWNrYWdlUGF0aCA9IHRyeUdldFB5b2RpZGVQYXRoKG9wdGlvbnMucHlvZGlkZURlcGVuZGVuY3lQYXRoKTtcbiAgICAgICAgY29uc3QgcGtnID0gdHJ5UmVzb2x2ZVB5b2RpZGVQYWNrYWdlKHB5b2RpZGVQYWNrYWdlUGF0aCwgb3B0aW9ucy52ZXJzaW9uKTtcbiAgICAgICAgb3B0aW9ucy5wYXR0ZXJucyA9IHBhdHRlcm5zLmNob29zZUFuZFRyYW5zZm9ybShwa2csIG9wdGlvbnMucGFja2FnZUluZGV4VXJsKS5tYXAoKHBhdHRlcm4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogcGF0aC5yZXNvbHZlKHB5b2RpZGVQYWNrYWdlUGF0aCwgcGF0dGVybi5mcm9tKSxcbiAgICAgICAgICAgICAgICB0bzogcGF0aC5qb2luKG91dERpcmVjdG9yeSwgcGF0dGVybi50byksXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBwYXR0ZXJuLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhc3NlcnQub2sob3B0aW9ucy5wYXR0ZXJucy5sZW5ndGggPiAwLCBgVW5zdXBwb3J0ZWQgdmVyc2lvbiBvZiBweW9kaWRlLiBNdXN0IHVzZSA+PSR7cGF0dGVybnMudmVyc2lvbnNbMF19YCk7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gZGVsZXRlIGFsbCBweW9kaWRlIHBsdWdpbiBvcHRpb25zIGJlZm9yZSBjYWxsaW5nIHN1cGVyLiBSZXN0IG9mIG9wdGlvbnMgcGFzc2VkIHRvIGNvcHkgd2VicGFjayBwbHVnaW5cbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucGFja2FnZUluZGV4VXJsO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5nbG9iYWxMb2FkUHlvZGlkZTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMub3V0RGlyZWN0b3J5O1xuICAgICAgICBkZWxldGUgb3B0aW9ucy52ZXJzaW9uO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5weW9kaWRlRGVwZW5kZW5jeVBhdGg7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdsb2JhbExvYWRQeW9kaWRlID0gZ2xvYmFsTG9hZFB5b2RpZGU7XG4gICAgfVxuICAgIGFwcGx5KGNvbXBpbGVyKSB7XG4gICAgICAgIHN1cGVyLmFwcGx5KGNvbXBpbGVyKTtcbiAgICAgICAgY29tcGlsZXIuaG9va3MuY29tcGlsYXRpb24udGFwKHRoaXMuY29uc3RydWN0b3IubmFtZSwgKGNvbXBpbGF0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21waWxhdGlvbkhvb2tzID0gd2VicGFjay5Ob3JtYWxNb2R1bGUuZ2V0Q29tcGlsYXRpb25Ib29rcyhjb21waWxhdGlvbik7XG4gICAgICAgICAgICBjb21waWxhdGlvbkhvb2tzLmJlZm9yZUxvYWRlcnMudGFwKHRoaXMuY29uc3RydWN0b3IubmFtZSwgKGxvYWRlcnMsIG5vcm1hbE1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBub3JtYWxNb2R1bGUudXNlclJlcXVlc3QubWF0Y2goL3B5b2RpZGVcXC5tP2pzJC8pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldyBsb2FkZXIgc3BlY2lmaWNhbGx5IHRvIGhhbmRsZSBweW9kaWRlLm0/anMuIFNlZSBsb2FkZXIudHMgZm9yIGZ1bmN0aW9uYWxpZHlcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlcjogcGF0aC5yZXNvbHZlKGRpcm5hbWUsIFwibG9hZGVyLmNqc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxMb2FkUHlvZGlkZTogdGhpcy5nbG9iYWxMb2FkUHlvZGlkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc01vZHVsZTogbWF0Y2hlc1swXS5lbmRzV2l0aChcIi5tanNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnQ6IFwicHlvZGlkZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVHJ5IHRvIGZpbmQgdGhlIHB5b2RpZGUgcGF0aC4gQ2FuJ3QgdXNlIHJlcXVpcmUucmVzb2x2ZSBiZWNhdXNlIGl0IGlzIG5vdCBzdXBwb3J0ZWQgaW5cbiAqIG1vZHVsZSBidWlsZHMuIE5vZGVzIGltcG9ydC5tZXRhLnJlc29sdmUgaXMgZXhwZXJpbWVudGFsIGFuZCBzdGlsbCB2ZXJ5IG5ldyBhcyBvZiBub2RlIDE5LnhcbiAqIFRoaXMgbWV0aG9kIGlzIHdvcmtzIHVuaXZlcnNhbGx5IHVuZGVyIHRoZSBhc3N1bXB0aW9uIG9mIGFuIGluc3RhbGwgaW4gbm9kZV9tb2R1bGVzL3B5b2RpZGVcbiAqIEBwYXJhbSBweW9kaWRlUGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdHJ5R2V0UHlvZGlkZVBhdGgocHlvZGlkZVBhdGgpIHtcbiAgICBpZiAocHlvZGlkZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgucmVzb2x2ZShweW9kaWRlUGF0aCk7XG4gICAgfVxuICAgIGxldCBweW9kaWRlRW50cnlwb2ludCA9IFwiXCI7XG4gICAgaWYgKHR5cGVvZiByZXF1aXJlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBweW9kaWRlRW50cnlwb2ludCA9IF9fbm9uX3dlYnBhY2tfcmVxdWlyZV9fLnJlc29sdmUoXCJweW9kaWRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBub29wKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpbXBvcnQubWV0YSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBlc20uLi5cbiAgICAgICAgICAgIGNvbnN0IHIgPSBjcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybCk7XG4gICAgICAgICAgICBweW9kaWRlRW50cnlwb2ludCA9IHIucmVzb2x2ZShcInB5b2RpZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG5vb3AoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2FsayA9IChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXQgPSBmcy5zdGF0U3luYyhwKTtcbiAgICAgICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB3YWxrKHBhdGguZGlybmFtZShwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgaWYgKHBhdGguYmFzZW5hbWUocCkgPT09IFwibm9kZV9tb2R1bGVzXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gbG9jYXRlIHB5b2RpZGUgcGFja2FnZS4gWW91IGNhbiBkZWZpbmUgaXQgbWFudWFsbHkgd2l0aCBweW9kaWRlUGF0aCBpZiB5b3UncmUgdHJ5aW5nIHRvIHRlc3Qgc29tZXRoaW5nIG5vdmVsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBkaXJlbnQgb2YgZnMucmVhZGRpclN5bmMocCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVudC5uYW1lICE9PSBcInBhY2thZ2UuanNvblwiIHx8IGRpcmVudC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwa2cgPSBmcy5yZWFkRmlsZVN5bmMocGF0aC5qb2luKHAsIGRpcmVudC5uYW1lKSwgXCJ1dGYtOFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGtnSnNvbiA9IEpTT04ucGFyc2UocGtnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBrZ0pzb24ubmFtZSA9PT0gXCJweW9kaWRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIHB5b2RpZGUgcGFja2FnZSByb290LiBFeGl0IHRoaXMgdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuYWJsZSB0byBsb2NhdGUgYW5kIHBhcnNlIHB5b2RpZGUgcGFja2FnZS5qc29uLiBZb3UgY2FuIGRlZmluZSBpdCBtYW51YWxseSB3aXRoIHB5b2RpZGVQYXRoIGlmIHlvdSdyZSB0cnlpbmcgdG8gdGVzdCBzb21ldGhpbmcgbm92ZWxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdhbGsocGF0aC5kaXJuYW1lKHApKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHdhbGsocHlvZGlkZUVudHJ5cG9pbnQpO1xufVxuLyoqXG4gKiBSZWFkIHRoZSBweW9kaWRlIHBhY2thZ2UgZGVwZW5kZW5jeSBwYWNrYWdlLmpzb24gdG8gcmV0dXJuIG5lY2Vzc2FyeSBtZXRhZGF0YVxuICogQHBhcmFtIHZlcnNpb25cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHRyeVJlc29sdmVQeW9kaWRlUGFja2FnZShweW9kaWRlUGF0aCwgdmVyc2lvbikge1xuICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHZlcnNpb24gfTtcbiAgICB9XG4gICAgY29uc3QgcGtnUGF0aCA9IHBhdGgucmVzb2x2ZShweW9kaWRlUGF0aCwgXCJwYWNrYWdlLmpzb25cIik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGtnID0gZnMucmVhZEZpbGVTeW5jKHBrZ1BhdGgsIFwidXRmLThcIik7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHBrZyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIHJlYWQgcGFja2FnZS5qc29uIGZyb20gcHlvZGlkZSBkZXBlbmRlbmN5IGluICR7cGtnUGF0aH1gKTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBQeW9kaWRlUGx1Z2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9